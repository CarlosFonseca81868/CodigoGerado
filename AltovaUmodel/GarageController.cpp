////////////////////////////////////////////////////////////////////////
//
// GarageController.cpp
//
// This file was generated by UModel 2022 Enterprise Edition
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the UModel Documentation for further details.
// http://www.altova.com/umodel
//
////////////////////////////////////////////////////////////////////////
#include <iostream>
#include <memory>
#include <string>
#include <vector>

#define private public
namespace com_nanonull {

class GarageController {
 public:
  enum class TStateId {
    GarageStateMachine_Root,
    GarageStateMachine_Region1_Fechada,
    GarageStateMachine_Region1_A_Abrir,
    GarageStateMachine_Region1_Aberta,
    GarageStateMachine_Region1_A_Fechar
  };

  struct IRegion;
  struct IState;
  using IRegionPtr = std::shared_ptr<IRegion>;
  using IStatePtr = std::shared_ptr<IState>;
  using RegionArray = std::vector<IRegionPtr>;
  using StateArray = std::vector<IStatePtr>;

  struct IState {
    virtual std::string getName() = 0;
    virtual TStateId getId() = 0;
    virtual RegionArray getRegions() = 0;
  };

  struct IRegion {
    virtual std::string getName() = 0;
    virtual StateArray getStates() = 0;
    virtual IStatePtr getCurrentState() = 0;
  };

  // get the Root State
 public:
  IStatePtr getRootState() {
    return _getRootState();
  }

 public:
  IStatePtr getCurrentTopLevelState() {
    return getRootState()->getRegions()[0]->getCurrentState();
  }

  // Initialize the State Machine
 public:
  void Initialize() {
    OnDebugMessage("BEGIN_INITIALIZE");
    GarageStateMachine_Region1_Fechada = std::make_shared<CGarageStateMachine::Region1::Fechada>(this);
    GarageStateMachine_Region1_A_Abrir = std::make_shared<CGarageStateMachine::Region1::A_Abrir>(this);
    GarageStateMachine_Region1_Aberta = std::make_shared<CGarageStateMachine::Region1::Aberta>(this);
    GarageStateMachine_Region1_A_Fechar = std::make_shared<CGarageStateMachine::Region1::A_Fechar>(this);

    rootState = std::make_shared<CGarageStateMachine>(this);

    CGarageStateMachine::Region1::setCurrentState(this, CGarageStateMachine::Region1::getInitState(this));
    OnDebugMessage("END_INITIALIZE");
  }

  // get all possible call event actions
 public:
  struct CallEvent {
    CallEvent(std::string name, bool (GarageController::*ptr)(void)) : Name(name), Pointer(ptr) {}
    bool run(GarageController* instance) { return (instance->*Pointer)(); }

    std::string Name;
    bool (GarageController::*Pointer)(void);
  };

 public:
  std::vector<CallEvent> getCallEvents() {
    return {
        CallEvent("botaoPremido", &GarageController::botaoPremido),
        CallEvent("fim_stop", &GarageController::fim_stop),
        CallEvent("stop", &GarageController::stop),
        CallEvent("stop_fecho", &GarageController::stop_fecho)};
  }

  // call event method implementations
 public:
  bool botaoPremido() {
    OnDebugMessage("BEGIN_EVENT: botaoPremido");

    bool bHandled = _getRootState()->botaoPremido();
    OnDebugMessage("END_EVENT: botaoPremido");
    return bHandled;
  }

 public:
  bool fim_stop() {
    OnDebugMessage("BEGIN_EVENT: fim_stop");

    bool bHandled = _getRootState()->fim_stop();
    OnDebugMessage("END_EVENT: fim_stop");
    return bHandled;
  }

 public:
  bool stop() {
    OnDebugMessage("BEGIN_EVENT: stop");

    bool bHandled = _getRootState()->stop();
    OnDebugMessage("END_EVENT: stop");
    return bHandled;
  }

 public:
  bool stop_fecho() {
    OnDebugMessage("BEGIN_EVENT: stop_fecho");

    bool bHandled = _getRootState()->stop_fecho();
    OnDebugMessage("END_EVENT: stop_fecho");
    return bHandled;
  }

  // Overwrite to handle entry/exit/do actions, transition effects,...:
 public:
  virtual void abrir() { OnDebugMessage("ACTION: abrir"); }

 public:
  virtual void fechar() { OnDebugMessage("ACTION: fechar"); }

  // Overwrite to handle debug messages:
 public:
  virtual void OnDebugMessage(std::string str) {
    std::cout << str << std::endl;
  }

  // Additional defined attributes of the controller class:
 public:
  bool NoObstacle;

  // Implementation for StateMachine 'GarageStateMachine'
 private:
  class CGarageStateMachine : public IState {
   private:
    GarageController* context;

   public:
    CGarageStateMachine(GarageController* context) {
      this->context = context;
    }

   public:
    std::string getName() {
      return "GarageStateMachine";
    }

   public:
    TStateId getId() {
      return TStateId::GarageStateMachine_Root;
    }

   public:
    RegionArray getRegions() {
      return {
          std::make_shared<Region1>(context)};
    }

   public:
    bool botaoPremido() {
      return Region1::getCurrentState(context)->botaoPremido();
    }

   public:
    bool fim_stop() {
      return Region1::getCurrentState(context)->fim_stop();
    }

   public:
    bool stop() {
      return Region1::getCurrentState(context)->stop();
    }

   public:
    bool stop_fecho() {
      return Region1::getCurrentState(context)->stop_fecho();
    }

    // Implementation for Region 'Region1'
   public:
    class Region1 : public IRegion {
     private:
      GarageController* context;

     public:
      class Region1State;

     public:
      Region1(GarageController* context) {
        this->context = context;
      }

     public:
      std::string getName() {
        return "Region1";
      }

     public:
      StateArray getStates() {
        return {
            std::make_shared<Fechada>(context),
            std::make_shared<A_Abrir>(context),
            std::make_shared<Aberta>(context),
            std::make_shared<A_Fechar>(context)};
      }

     public:
      IStatePtr getCurrentState() {
        return getCurrentState(context);
      }

     public:
      static std::shared_ptr<Region1State> getCurrentState(GarageController* context) {
        return context->_getRootState()->svRegion1;
      }

     public:
      static void setCurrentState(GarageController* context, std::shared_ptr<Region1State> state) {
        context->OnDebugMessage("SET_CURRENT_STATE: " + state->getName());
        context->_getRootState()->svRegion1 = state;
        context->_getRootState()->svRegion1->entryState();
      }

     public:
      static std::shared_ptr<Region1State> getInitState(GarageController* context) {
        return context->GarageStateMachine_Region1_Fechada;
      }

      // Base class for all states of Region 'Region1'
     public:
      class Region1State : public IState {
       protected:
        GarageController* context;

       public:
        virtual bool botaoPremido() { return false; }

       public:
        virtual bool fim_stop() { return false; }

       public:
        virtual bool stop() { return false; }

       public:
        virtual bool stop_fecho() { return false; }

       public:
        virtual void entryState() {}
        virtual std::string getName() = 0;
        virtual TStateId getId() = 0;
        virtual RegionArray getRegions() = 0;
      };

      // Implementation for State 'Fechada'
     public:
      class Fechada : public Region1State {
       public:
        Fechada(GarageController* context) {
          this->context = context;
        }

       public:
        std::string getName() {
          return "Fechada";
        }

       public:
        TStateId getId() {
          return TStateId::GarageStateMachine_Region1_Fechada;
        }

       public:
        RegionArray getRegions() {
          return {};
        }

       public:
        bool botaoPremido() {
          // Handle Fechada ---> A_Abrir
          context->OnDebugMessage("TRANSITION: Fechada ---> A_Abrir");
          CGarageStateMachine::Region1::setCurrentState(context, context->GarageStateMachine_Region1_A_Abrir);
          return true;
        }
      };

      // Implementation for State 'A_Abrir'
     public:
      class A_Abrir : public Region1State {
       public:
        A_Abrir(GarageController* context) {
          this->context = context;
        }

       public:
        std::string getName() {
          return "A_Abrir";
        }

       public:
        TStateId getId() {
          return TStateId::GarageStateMachine_Region1_A_Abrir;
        }

       public:
        RegionArray getRegions() {
          return {};
        }

       public:
        bool stop() {
          // Handle A_Abrir ---> Aberta
          context->OnDebugMessage("TRANSITION: A_Abrir ---> Aberta");
          CGarageStateMachine::Region1::setCurrentState(context, context->GarageStateMachine_Region1_Aberta);
          return true;
        }

       public:
        void entryState() {
          context->abrir();
        }
      };

      // Implementation for State 'Aberta'
     public:
      class Aberta : public Region1State {
       public:
        Aberta(GarageController* context) {
          this->context = context;
        }

       public:
        std::string getName() {
          return "Aberta";
        }

       public:
        TStateId getId() {
          return TStateId::GarageStateMachine_Region1_Aberta;
        }

       public:
        RegionArray getRegions() {
          return {};
        }

       public:
        bool fim_stop() {
          if (true) {
            // Handle Aberta ---> A_Fechar
            context->OnDebugMessage("TRANSITION: Aberta ---> A_Fechar");
            context->fechar();  // Handle effect of transition Aberta ---> A_Fechar
            CGarageStateMachine::Region1::setCurrentState(context, context->GarageStateMachine_Region1_A_Fechar);
            return true;
          }
          return false;
        }
      };

      // Implementation for State 'A_Fechar'
     public:
      class A_Fechar : public Region1State {
       public:
        A_Fechar(GarageController* context) {
          this->context = context;
        }

       public:
        std::string getName() {
          return "A_Fechar";
        }

       public:
        TStateId getId() {
          return TStateId::GarageStateMachine_Region1_A_Fechar;
        }

       public:
        RegionArray getRegions() {
          return {};
        }

       public:
        bool fim_stop() {
          // Handle A_Fechar ---> Fechada
          context->OnDebugMessage("TRANSITION: A_Fechar ---> Fechada");
          CGarageStateMachine::Region1::setCurrentState(context, context->GarageStateMachine_Region1_Fechada);
          return true;
        }

       public:
        bool stop_fecho() {
          // Handle A_Fechar ---> A_Abrir
          context->OnDebugMessage("TRANSITION: A_Fechar ---> A_Abrir");
          CGarageStateMachine::Region1::setCurrentState(context, context->GarageStateMachine_Region1_A_Abrir);
          return true;
        }
      };
    };

   private:
    std::shared_ptr<Region1::Region1State> svRegion1;  // State Variable for Region 'Region1'
  };

  // Internal Definitions and Implementations

  // Root State Definition
 private:
  std::shared_ptr<CGarageStateMachine> rootState = nullptr;

 private:
  std::shared_ptr<CGarageStateMachine> _getRootState() {
    if (rootState == nullptr)
      Initialize();

    return rootState;
  }

  // State Variable Definitions
 private:
  std::shared_ptr<CGarageStateMachine::Region1::Fechada> GarageStateMachine_Region1_Fechada = nullptr;

 private:
  std::shared_ptr<CGarageStateMachine::Region1::A_Abrir> GarageStateMachine_Region1_A_Abrir = nullptr;

 private:
  std::shared_ptr<CGarageStateMachine::Region1::Aberta> GarageStateMachine_Region1_Aberta = nullptr;

 private:
  std::shared_ptr<CGarageStateMachine::Region1::A_Fechar> GarageStateMachine_Region1_A_Fechar = nullptr;
};
;
};  // namespace com_nanonull

int main(int argc, char** argv) {
  using namespace com_nanonull;

  GarageController* controller = new GarageController;
  controller->Initialize();
  // controller->Step1();
  // controller->Step2();
  // controller->getCallEvents()[0].run((controller));
  int i = 0;
  while (i <= 100) {
    for (auto event : controller->getCallEvents()) {
      event.run(controller);
      i++;
      if (i == 100)
        break;
    }
  }

  return 0;
}
